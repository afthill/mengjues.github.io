<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Joblib: the memoize and parallelism and persistence framework | Make Fun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="joblib项目地址：https://github.com/joblib/joblib 这个库主要提供三方面的功能：  缓存(cache, memoize) 并发(parallelism) 序列化(persistence)  这三个是程序设计与开发中最常见的功能，而该库的主要作用是：  通过抽象封装，减少开发人员在程序设计与实现中容易出现的错误 修复python的内建库不能处理的小bug  主要包">
<meta name="keywords" content="Memoize,Parallelism,Persistence">
<meta property="og:type" content="article">
<meta property="og:title" content="Joblib: the memoize and parallelism and persistence framework">
<meta property="og:url" content="http://m.imf.cc/2015/12/24/joblib-the-memoize-and-parallelism-and-persistence-framework/index.html">
<meta property="og:site_name" content="Make Fun">
<meta property="og:description" content="joblib项目地址：https://github.com/joblib/joblib 这个库主要提供三方面的功能：  缓存(cache, memoize) 并发(parallelism) 序列化(persistence)  这三个是程序设计与开发中最常见的功能，而该库的主要作用是：  通过抽象封装，减少开发人员在程序设计与实现中容易出现的错误 修复python的内建库不能处理的小bug  主要包">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-01-31T01:39:44.280Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joblib: the memoize and parallelism and persistence framework">
<meta name="twitter:description" content="joblib项目地址：https://github.com/joblib/joblib 这个库主要提供三方面的功能：  缓存(cache, memoize) 并发(parallelism) 序列化(persistence)  这三个是程序设计与开发中最常见的功能，而该库的主要作用是：  通过抽象封装，减少开发人员在程序设计与实现中容易出现的错误 修复python的内建库不能处理的小bug  主要包">
  
  
  <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/open-fonts/css/open-sans.css">
  <link rel="stylesheet" href="/open-fonts/css/share-tech-mono.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  

</head>
</html>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo"></i><span class="site-title">Make Fun</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div class="profile" id="profile-nav">
          <a id="profile-anchor" href="javascript:;"><img class="avatar" src="/css/images/avatar.png"><i class="fa fa-caret-down"></i></a>
        </div>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="http://m.imf.cc"></form>
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
      
        <td><a class="main-nav-link" href="/">Home</a></td>
      
        <td><a class="main-nav-link" href="/archives">Archives</a></td>
      
        <td><a class="main-nav-link" href="/about">About</a></td>
      
      <td>
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://m.imf.cc"></form>
      </td>
      </tr>
    </table>
  </div>
  
</header>
    <div class="outer">
      <aside id="profile">
  <div class="inner profile-inner">
  	<div class="base-info profile-block">
		  <img id="avatar" src="/css/images/avatar.png">
      <h2 id="name">Meng Jue (M)</h2>
      <h3 id="title">Strict Developer &amp; Funny Player</h3>
      <span id="location"><i class="fa fa-map-marker"></i>Shanghai, China</span>
      <a id="follow" href="https://github.com/MengjueM">关注我</a>
  	</div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        319
        <span>文章</span>
      </div>
      <div class="article-info-block">
        236
        <span>标签</span>
      </div>
    </div>
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
        
          <td><a href="http://github.com/MengjueM" title="github"><i class="fa fa-github"></i></a></td>
        
          <td><a href="#" title="twitter"><i class="fa fa-twitter"></i></a></td>
        
          <td><a href="#" title="facebook"><i class="fa fa-facebook"></i></a></td>
        
          <td><a href="#" title="dribbble"><i class="fa fa-dribbble"></i></a></td>
        
          <td><a href="/atom.xml" title="rss"><i class="fa fa-rss"></i></a></td>
        
        </tr>
      </table>
    </div>
  </div>
</aside>
      <section id="main"><article id="post-joblib-the-memoize-and-parallelism-and-persistence-framework" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Joblib: the memoize and parallelism and persistence framework
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2015/12/24/joblib-the-memoize-and-parallelism-and-persistence-framework/">
    <time datetime="2015-12-24T09:07:37.000Z" itemprop="datePublished">2015-12-24</time>
  </a>
</div>
          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Solutions/">方案</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>joblib项目地址：<a href="https://github.com/joblib/joblib" target="_blank" rel="noopener">https://github.com/joblib/joblib</a></p>
<p>这个库主要提供三方面的功能：</p>
<ul>
<li>缓存(cache, memoize)</li>
<li>并发(parallelism)</li>
<li>序列化(persistence)</li>
</ul>
<p>这三个是程序设计与开发中最常见的功能，而该库的主要作用是：</p>
<ul>
<li>通过抽象封装，减少开发人员在程序设计与实现中容易出现的错误</li>
<li>修复python的内建库不能处理的小bug</li>
</ul>
<p>主要包含三个类：Memory、Parallel、MemorizedFunc<br><a id="more"></a></p>
<h2 id="Memory类"><a href="#Memory类" class="headerlink" title="Memory类:"></a>Memory类:</h2><p>Memory类是joblib提供的缓存功能的入口，生成的memory对象通过cache、clear、eval提供对<br>缓存功能的管理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">joblib</span>.<span class="title">memory</span>.<span class="title">Memory</span><span class="params">(cachedir, mmap_mode=None, compress=False, verbose=<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Memory定义的是一个context对象，该context对象用来缓存一个function的返回值；</span></span><br><span class="line"><span class="string">所有缓存的值都存在文件系统里。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cachedir, mmap_mode=None, compress=False, verbose=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    cachedir: (string | None)</span></span><br><span class="line"><span class="string">    用来指定文件存储的位置的根目录，如果设定为None，则cache机制会完全失效，</span></span><br><span class="line"><span class="string">    返回的Memory对象是透明的；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mmap_mode: (None | r+ | w+ | r | c)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这个参数的主要作用是用来处理numpy的memory view数组，</span></span><br><span class="line"><span class="string">    memoryview在python中也有专门的模块来处理，主要用来解决大块数据拷贝的性能问题，</span></span><br><span class="line"><span class="string">    不同python/OS api去拷贝，而是直接开发内存操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    compress: (boolean | integer)</span></span><br><span class="line"><span class="string">    用来指定序列化在文件系统中的内容的压缩等级，如果设定为False，就表示不压缩，</span></span><br><span class="line"><span class="string">    如果设定为整数，只能是在1~9。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    verbose: (int)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    用来控制是否显示debug信息。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cache</span><span class="params">(func=None, ignore=None, verbose=None, mmap_mode=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        func: (callable)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        被decorator标记的function。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ignore: (list of string)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        需要在hashing化时，排除掉的关键词列表。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        verbose: (integer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        用来控制function是否开启verbose模式。默认使用memory对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mmap_mode: (None | r+ | r | w+ | c)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        用来控制numpy array缓存的载入模式。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decoreated_func: MemorizedFunc object</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回的是被注入的function，是一个MemorizedFunc对象。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(warn=True)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用来删除cache根目录</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(func, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用指定的参数（*args **kwargs），在memory的上下文环境中，执行传入的function。</span></span><br><span class="line"><span class="string">        类似于原生库里的apply，除了该函数只在cache没有更新的时候调用。</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure>
<h2 id="MemorizedFunc类"><a href="#MemorizedFunc类" class="headerlink" title="MemorizedFunc类"></a>MemorizedFunc类</h2><p>MemorizedFunc类是经过Memory.cache修饰后返回的修饰对象（decorated function），除了<br>可以提供正常的function功能之外，还可以提供对缓存的管理和内窥。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">joblib</span>.<span class="title">memory</span>.<span class="title">MemorizedFunc</span><span class="params">(func, cachedir, ignore=None, mmap_mode=None,</span></span></span><br><span class="line"><span class="class"><span class="params">compress=False, verbose=<span class="number">1</span>, timestamp=None)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">MemorizedFunc是一个callable对象，这个callable对象用来修饰需要缓存功能的function，然</span></span><br><span class="line"><span class="string">后就可以缓存该function所返回的值；</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(func, cachedir, ignore=True, mmap_mode=None, compress=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    verbose=<span class="number">1</span>, timestamp=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    func: (callable)</span></span><br><span class="line"><span class="string">    用来表示被修饰的function对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cachedir: (string)</span></span><br><span class="line"><span class="string">    缓存数据的存储路径的根目录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ignore: (list | None)</span></span><br><span class="line"><span class="string">    不缓存的变量列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mmap_mode: (None | r+ | r | w+ | c)</span></span><br><span class="line"><span class="string">    主要跟numpy的内存管理有关</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    compress: (boolean | integer)</span></span><br><span class="line"><span class="string">    缓存在文件系统中的压缩等级（1~9）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    verbose: (int)</span></span><br><span class="line"><span class="string">    控制debug信息的输出等级</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    timestamp: (float)</span></span><br><span class="line"><span class="string">    trace信息输出时的参考时间点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用指定的（*args, **kwargs）执行函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    清空function的缓存</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_output_dir</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回使用指定的（*args, **kwargs）执行function时，结果被缓存所在的目录；</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_output</span><span class="params">(output_dir)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回之前缓存在指定的目录里的值</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure>
<h2 id="Parallel类"><a href="#Parallel类" class="headerlink" title="Parallel类"></a>Parallel类</h2><p>Parallel类是一个可读性更好实现并发方案的帮助类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parallel</span><span class="params">(n_jobs=<span class="number">1</span>, backend=<span class="string">'multiprocessing'</span>, verbose=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">pre_dispatch=<span class="string">'2 * n_jobs'</span>, batch_size=<span class="string">'auto'</span>, temp_folder=None,</span></span></span><br><span class="line"><span class="class"><span class="params">max_nbytes=<span class="string">'1M'</span>, mmap_mode=<span class="string">'r'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">njobs: (int | 1)</span></span><br><span class="line"><span class="string">用来指定最大的可以并发运行的jobs，如果backend被指定为multiprocessing，</span></span><br><span class="line"><span class="string">那这里的jobs就是最大的工作进程数，如果backend被指定为threading，那就是</span></span><br><span class="line"><span class="string">thread pool的大小。如果指定为-1，那表示所有的cpu都被用来计算；如果为1，</span></span><br><span class="line"><span class="string">那表示没有任何并发计算，这个功能主要被用来debug。如果n_jobs低于-1，那</span></span><br><span class="line"><span class="string">计算的方式为：(n_cpus + 1 + n_jobs)。因此，如果n_jobs是-1，那用到的</span></span><br><span class="line"><span class="string">cpu个数为：n_cpus - 1 (all cpus but one)。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">backend: (str | None | default: multiprocessing)</span></span><br><span class="line"><span class="string">指定后端并发的具体实现：</span></span><br><span class="line"><span class="string">- multiprocessing: 缺省的并发使用方案，可以有更多的在communication</span></span><br><span class="line"><span class="string">和memory的消耗。</span></span><br><span class="line"><span class="string">- threading：由于Python中GIL的存在，如果在计算中使用了大量的Python</span></span><br><span class="line"><span class="string">对象，那么使用threading将不会是好的并发方案；threading的特点是比较</span></span><br><span class="line"><span class="string">低的context switch和communication的overhead。但是如果使用python的</span></span><br><span class="line"><span class="string">扩展避开了GIL的限制，那使用threading将会是较优的方案。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">veirbose: (int)</span></span><br><span class="line"><span class="string">控制输出的日志级别，如果值为非0，那么任务的执行进度将会被打印；如果超</span></span><br><span class="line"><span class="string">过10，所有的interation都会被打印；如果超过50，那将会把结果输出到stdout。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pre_dispatch: (all | integer | expression | 2 * n_jobs)</span></span><br><span class="line"><span class="string">预分派的任务数，如果batch_size的大小设为auto，则任务数就是2 * n_jobs</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">batch_size: (int | auto | defaut)</span></span><br><span class="line"><span class="string">每次分配给worker的原子任务数。当单个的任务数可以很快被处理的时候，多进程</span></span><br><span class="line"><span class="string">可能比顺序执行的速度还要慢，因为多进程的调度消耗了overhead。批处理的任务</span></span><br><span class="line"><span class="string">数的意义在于，分配给worker的任务的大小是动态的，基于计算的速度去保证每个</span></span><br><span class="line"><span class="string">workder的完成时间在半秒之内。初始的batch_size大小是1。当使用batch_size</span></span><br><span class="line"><span class="string">=auto而且backend="threading"的时候，将对每一个任务作为一个batch，因为</span></span><br><span class="line"><span class="string">threading在context switch的时候，overhead很小，在这里用较大的batch size</span></span><br><span class="line"><span class="string">毫无意义。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">temp_folder: (str)</span></span><br><span class="line"><span class="string">只在backend="multiprocessing"的时候被使用，主要用来作为大数组的内存映射的</span></span><br><span class="line"><span class="string">缓存池，这些缓存池然后被worker进程使用。如果设为None，将会按照如下顺序设定：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- JOBLIB_TEMP_FOLDER所指向的文件夹</span></span><br><span class="line"><span class="string">- /dev/shm存在而且是可写的，这是一个linux默认放置ramdisk的地方</span></span><br><span class="line"><span class="string">- TMP、TEMP、TMPDIR环境变量所指向的文件夹</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">max_nbytes: (int | str | None | 1M by default)</span></span><br><span class="line"><span class="string">用来设定传递给workder的数组大小的上限，这些数组将会自动在temp_folder中做内存</span></span><br><span class="line"><span class="string">映射。可以使用int Bytes或者1 M，或者None，如果使用None，则表示不适用内存映射。</span></span><br><span class="line"><span class="string">只在backend="multiprocessing"中使用。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="按需重复计算：Memory类"><a href="#按需重复计算：Memory类" class="headerlink" title="按需重复计算：Memory类"></a>按需重复计算：Memory类</h3><p>Memory类定义的是一个：惰性求值（evaluation）的上下文环境，通过存储结果到操作系统<br>的文件系统中，保证不对传入的同样的参数（argument）重复计算两次。设计该类的主要用途<br>是：可以接受传入non-hashable的大数组参数而得到numpy类型的新的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tempfile import mkdtemp</span><br><span class="line">cachedir = mkdtemp()</span><br><span class="line"></span><br><span class="line">from joblib import Memory</span><br><span class="line">memory = Memory(cachedir=cachedir, verbose=0)</span><br><span class="line"></span><br><span class="line">@memory.cache</span><br><span class="line">def f(x):</span><br><span class="line">    print &apos;Running f(%s)&apos; % x</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print f(1)</span><br><span class="line">&gt;&gt;&gt; Running f(1)</span><br><span class="line">&gt;&gt;&gt; 1</span><br><span class="line"></span><br><span class="line">print f(1)</span><br><span class="line">&gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure>
<h3 id="与memoize的比较"><a href="#与memoize的比较" class="headerlink" title="与memoize的比较"></a>与memoize的比较</h3><blockquote>
<p><a href="http://code.activestate.com/recipes/52201/" target="_blank" rel="noopener">The memoize decorator</a>主要通过<br>比较输入参数比较来缓存function的计算结果，但是它的缺点如下：</p>
</blockquote>
<blockquote>
<ul>
<li>每一次函数被调用时，都会比较在缓存中的input（也即传入的参数），如果是大的input<br>就会产生大量的overhead</li>
<li>不能接受numpy array作为input</li>
<li>需要大量的内存，因为cache是放在内存中</li>
</ul>
</blockquote>
<p>而对于joblib的Memory类，对象是被序列化到硬盘，然后使用一个persister去优化速度和对<br>内存的使用。</p>
<p>因此结论是：</p>
<p>memoize是比较适合于较小的input和output缓存，而Memory类则比较适合于复杂的input和<br>output。    </p>
<h3 id="with-numpy"><a href="#with-numpy" class="headerlink" title="with numpy"></a>with numpy</h3><p>Memory类使用快速加密哈希算法去检查input是否已经被计算过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">@memory.cache</span><br><span class="line">def g(x):</span><br><span class="line">    print &apos;A long running calculation, with parameter %s&apos; % x</span><br><span class="line">    return np.hamming(x)</span><br><span class="line"></span><br><span class="line">@memory.cache</span><br><span class="line">def h(x):</span><br><span class="line">    print &apos;A second long running calculation, using g(x)&apos;</span><br><span class="line">    return np.vander(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = g(3)</span><br><span class="line">A long-running calculation, with parameter 3</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([ 0.08,  1.  ,  0.08])</span><br><span class="line">&gt;&gt;&gt; g(3)</span><br><span class="line">array([ 0.08,  1.  ,  0.08])</span><br><span class="line">&gt;&gt;&gt; b = h(a)</span><br><span class="line">A second long-running calculation, using g(x)</span><br><span class="line">&gt;&gt;&gt; b2 = h(a)</span><br><span class="line">&gt;&gt;&gt; b2</span><br><span class="line">array([[ 0.0064,  0.08  ,  1.    ],</span><br><span class="line">       [ 1.    ,  1.    ,  1.    ],</span><br><span class="line">       [ 0.0064,  0.08  ,  1.    ]])</span><br><span class="line">&gt;&gt;&gt; np.allclose(b, b2)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h3 id="using-memmapping"><a href="#using-memmapping" class="headerlink" title="using memmapping"></a>using memmapping</h3><p>如果对numpy的数组加速，我们可以开启memory mapping：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; cachedir2 = mkdtemp()</span><br><span class="line">&gt;&gt;&gt; memory2 = Memory(cachedir=cachedir2, mmap_mode=&apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; square = memory2.cache(np.square)</span><br><span class="line">&gt;&gt;&gt; a = np.vander(np.arange(3)).astype(np.float)</span><br><span class="line">&gt;&gt;&gt; square(a)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; res = square(a)</span><br><span class="line">&gt;&gt;&gt; print(repr(res))</span><br><span class="line">memmap([[  0.,   0.,   1.],</span><br><span class="line">       [  1.,   1.,   1.],</span><br><span class="line">       [ 16.,   4.,   1.]])</span><br></pre></td></tr></table></figure>
<p>我们必须记得手动关闭memory mapping，以避免在windows中的文件死锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在内存映射中使用<code>&#39;r&#39;</code>模式，则内存是只读的，不可能in place修改。<br>如果使用<code>&#39;r+&#39;</code>或者<code>&#39;w+&#39;</code>，则对内存的修改将会同时修改缓存的文件而破坏<br>了缓存，因此我们可以使用<code>&#39;c&#39;</code>模式，表示copy on write!</p>
</blockquote>
<h3 id="Reference-to-cache-values"><a href="#Reference-to-cache-values" class="headerlink" title="Reference to cache values"></a>Reference to cache values</h3><p>当有一个大的numpy数组需要被dispatch几个worker时候，我们可以pass一个<br>cache的reference，而不是数据本身，然后每个worker可以通过传入的reference<br>自己去缓存里拿取需要的数据。</p>
<p>设立一个缓存的reference，可以通过一个wrapped的function：<code>call_and_shelve</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result = g.call_and_shelve(4)</span><br><span class="line">A long-running calculation, with parameter 4</span><br><span class="line">&gt;&gt;&gt; result  </span><br><span class="line">MemorizedResult(cachedir=&quot;...&quot;, func=&quot;g...&quot;, argument_hash=&quot;...&quot;)</span><br></pre></td></tr></table></figure>
<p>如果上面的reference计算完毕的时候，g的output将会从内存中删除，同时存储在文件<br>里，如果需要获得reference的值，可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result.get()</span><br><span class="line">&gt;&gt;&gt; array([ 0.08,  0.77,  0.77,  0.08])</span><br></pre></td></tr></table></figure>
<p>cache可以被清除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; result.clear()</span><br><span class="line">&gt;&gt;&gt; result.get()  </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">KeyError: &apos;Non-existing cache value (may have been cleared).\n</span><br><span class="line">File ... does not exist&apos;</span><br></pre></td></tr></table></figure>
<p>reference存储的是MemorizedResult类型，包含了所有的必须用来读取cache的数据，<br>这些数据可以被pickle或者print或者copy paste。</p>
<blockquote>
<p>如果Memory(cachedir=None)，则<code>call_and_shelve</code>返回的是NotMemorizedResult对<br>象，这个对象包含了所有的output，而不是reference。</p>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>不同的session中，function的缓存是基于function name</li>
<li>lambda function，因为是匿名函数，没法把两个不同的lambda分开</li>
<li>memory cache不同被用在复杂的对象了，比如对象有<code>__callable__</code></li>
<li>caching methods:<ul>
<li>不能decorate class method at definition time</li>
<li>只能decorate at instantiation time</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    @mem.cache # WRONG</span><br><span class="line">    def method(self, args):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self, args):</span><br><span class="line">        self.method = mem.cache(self.method)</span><br><span class="line"></span><br><span class="line">    def method(self, ...):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><p>有时候在计算input的hash的时候，我们可以忽略因为debug加入的额外的参数，<br>只需要把这些参数加入ignore_list即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; @memory.cache(ignore=[&apos;debug&apos;])</span><br><span class="line">... def my_func(x, debug=True):</span><br><span class="line">...     print(&apos;Called with x = %s&apos; % x)</span><br><span class="line">&gt;&gt;&gt; my_func(0)</span><br><span class="line">Called with x = 0</span><br><span class="line">&gt;&gt;&gt; my_func(0, debug=False)</span><br><span class="line">&gt;&gt;&gt; my_func(0, debug=True)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Parallel-for-loops"><a href="#Parallel-for-loops" class="headerlink" title="Parallel for loops"></a>Parallel for loops</h3><p>Joblib提供了一个很简单的帮助类，用来并发执行loops里面的计算，核心思想是<br>利用python中的generator和parallel计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">[sqrt(i ** 2) for i in range(10)]</span><br><span class="line">&gt;&gt;&gt; [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]</span><br></pre></td></tr></table></figure>
<p>上面的程序可以用2个cpu来计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">from joblib import Parallel, delayed</span><br><span class="line">Parallel(n_jobs=2)(delayed(sqrt)(i ** 2) for i in range(10))</span><br><span class="line">&gt;&gt;&gt; [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]</span><br></pre></td></tr></table></figure>
<p>这里的Parallel对象创建了一个多进程池，然后分叉python的解释器在多个进程里<br>运行。</p>
<p>delayed函数是一个wrapper，用来执行类似于<code>（func，*args， **kwargs）</code>的行<br>为。</p>
<p>在windows系统中，需要保护main loop去避免在使用joblib.Parallel的时候遇到<br>递归的子进程分叉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ...</span><br><span class="line"></span><br><span class="line">def function1(...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">def function2(...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # do stuff with imports and functions defined about</span><br></pre></td></tr></table></figure>
<p>在<code>if __name__ == &#39;__main__&#39;</code>之外，应该只有definitions和imports，所有代码<br>的运行动作都应该是在<code>main</code>中。</p>
<h4 id="使用threading作为计算后端"><a href="#使用threading作为计算后端" class="headerlink" title="使用threading作为计算后端"></a>使用threading作为计算后端</h4><p>默认joblib使用multiprocessing去执行并发计算的任务，因为process之间的通信带来<br>的overhead，导致在执行一些nogil的任务的时候，可以采用低overhead的threading。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Parallel(n_jobs=2, backend=&quot;threading&quot;)(</span><br><span class="line">...     delayed(sqrt)(i ** 2) for i in range(10))</span><br><span class="line">[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]</span><br></pre></td></tr></table></figure>
<h4 id="重用工作池"><a href="#重用工作池" class="headerlink" title="重用工作池"></a>重用工作池</h4><p>由于某些计算需要处理中间过程产生的值，不停的创建和销毁工作池并维护状态是一个很大的<br>负担，因此，我们可以通过使用Parallel提供的context manager去重用工作池：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; with Parallel(n_jobs=2) as parallel:</span><br><span class="line">...    accumulator = 0.</span><br><span class="line">...    n_iter = 0</span><br><span class="line">...    while accumulator &lt; 1000:</span><br><span class="line">...        results = parallel(delayed(sqrt)(accumulator + i ** 2)</span><br><span class="line">...                           for i in range(5))</span><br><span class="line">...        accumulator += sum(results)  # synchronization barrier</span><br><span class="line">...        n_iter += 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; (accumulator, n_iter)                            </span><br><span class="line">(1136.596..., 14)</span><br></pre></td></tr></table></figure>
<h3 id="并发计算时的共享内存模式（memory-mapping）"><a href="#并发计算时的共享内存模式（memory-mapping）" class="headerlink" title="并发计算时的共享内存模式（memory mapping）"></a>并发计算时的共享内存模式（memory mapping）</h3><p>如果task的input很大，那么在并发计算时，需要把这些input分发（dispatch）给不同的<br>worker，在分发的时候，需要不停reallocate input产生的内存，这也是一个很大的开销，<br>因此我们引进了共享内存模式，在不同的进程之间共享内存数据。</p>
<h4 id="将数组转化为共享数组"><a href="#将数组转化为共享数组" class="headerlink" title="将数组转化为共享数组"></a>将数组转化为共享数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from joblib import Parallel, delayed</span><br><span class="line">from joblib.pool import has_shared_memory</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Parallel(n_jobs=2, max_nbytes=1e6)(</span><br><span class="line">...     delayed(has_shareable_memory)(np.ones(int(i)))</span><br><span class="line">...     for i in [1e2, 1e4, 1e6])</span><br><span class="line">[False, False, True]</span><br></pre></td></tr></table></figure>
<p>缺省数据是被放在<code>/dev/shm</code>共享内存分区里，如果存在并可写的话。如果不存在，操作<br>系统会自动使用临时目录。</p>
<p>如果设定<code>max_nbytes=None</code>则表示进制数组转化为共享内存。</p>
<h4 id="手动管理共享内存"><a href="#手动管理共享内存" class="headerlink" title="手动管理共享内存"></a>手动管理共享内存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">large_array = np.ones(int(1e6))</span><br></pre></td></tr></table></figure>
<p>放到文件里用来做共享内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tempfile</span><br><span class="line">import os</span><br><span class="line">from joblib import load, dump</span><br><span class="line"></span><br><span class="line">temp_folder = tempfile.mkdtemp()</span><br><span class="line">filename = os.path.join(temp_folder, &apos;joblib_test.mmap&apos;)</span><br><span class="line">if os.path.exists(filename): os.unlink(filename)</span><br><span class="line">_ = dump(large_array, filename)</span><br><span class="line">large_memmap = load(filename, mmap_mode=&apos;r+&apos;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; large_memmap.__class__.__name__, large_array.nbytes, large_array.shape</span><br><span class="line">(&apos;memmap&apos;, 8000000, (1000000,))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.allclose(large_array, large_memmap)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>可以从主进程里释放远处的数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del large_array</span><br><span class="line">import gc</span><br><span class="line">_ = gc.collect()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">small_memmap = large_memmap[2:5]</span><br><span class="line">&gt;&gt;&gt; small_memmap.__class__.__name__, small_memmap.nbytes, small_memmap.shape</span><br><span class="line">(&apos;memmap&apos;, 24, (3,))</span><br></pre></td></tr></table></figure>
<p>np.ndarray view:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; small_array = np.asarray(small_memmap)</span><br><span class="line">&gt;&gt;&gt; small_array.__class__.__name__, small_array.nbytes, small_array.shape</span><br><span class="line">(&apos;ndarray&apos;, 24, (3,))</span><br></pre></td></tr></table></figure>
<p>上面实现的3个新的数据结构，全部指向的是同一个内存buffer：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Parallel(n_jobs=2, max_nbytes=None)(</span><br><span class="line">...     delayed(has_shareable_memory)(a)</span><br><span class="line">...     for a in [large_memmap, small_memmap, small_array])</span><br><span class="line">[True, True, True]</span><br></pre></td></tr></table></figure>
<p>最后要记得清洗临时文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import shutil</span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     shutil.rmtree(temp_folder)</span><br><span class="line">... except OSError:</span><br><span class="line">...     pass  # this can sometimes fail under Windows</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><p>对于大的numpy的arrays，joblib.dump和joblib.load提供了对pickle的替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tempfile import mkdtemp</span><br><span class="line">savedir = mkdtemp()</span><br><span class="line">import os</span><br><span class="line">filename = os.path.join(savedir, &apos;test.pkl&apos;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">to_persist = [(&apos;a&apos;, [1, 2, 3]), (&apos;b&apos;, np.arange(10))]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import joblib</span><br><span class="line">joblib.dump(to_persist, filename)</span><br><span class="line">&gt;&gt; [&apos;...test.pkl&apos;, &apos;...test.pkl_01.npy&apos;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joblib.load(filename)</span><br><span class="line">&gt;&gt; [(&apos;a&apos;, [1, 2, 3]), (&apos;b&apos;, array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]))]</span><br></pre></td></tr></table></figure>
<p>当使用joblib.dump去存储数据的时候，joblib把数据是存储在多个文件中，因此当<br>转移pickle文件时，需要把所有的文件一起拷贝。</p>
<h4 id="压缩joblib-pickle"><a href="#压缩joblib-pickle" class="headerlink" title="压缩joblib pickle"></a>压缩joblib pickle</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; joblib.dump(to_persist, filename, compress=True)  </span><br><span class="line">[&apos;.../test.pkl&apos;]</span><br></pre></td></tr></table></figure>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>joblib不支持不同python版本之间的兼容性。</p>
<p>···end···</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://m.imf.cc/2015/12/24/joblib-the-memoize-and-parallelism-and-persistence-framework/" data-id="cjrjycruu00obbatixkq052zq" class="article-share-link">分享到</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memoize/">Memoize</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Parallelism/">Parallelism</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Persistence/">Persistence</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/29/marshmallow-ORM-framework-in-Python/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ORM？不是数据库的专利
        
      </div>
    </a>
  
  
    <a href="/2015/12/24/tqdm-a-progress-bar-implementation-in-python/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">tqdm: 一个命令行进度条的python实现</div>
    </a>
  
</nav>

  
</article>

</section>
      
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML5/">HTML5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">Security</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Innards/">内核</a><span class="category-list-count">48</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Functional-Programming/">函数编程</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dynamic-Programming/">动态编程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Fun/">好玩</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">安卓</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Recommend/">推荐</a><span class="category-list-count">57</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">数学</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solutions/">方案</a><span class="category-list-count">64</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MachineLearning/">机器学习</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Testing/">测试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">程序语言</a><span class="category-list-count">71</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">笔记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algo/">算法</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Automation/">自动化</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerVision/">计算机视觉</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Review/">评测</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interview/">面试</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">49</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">32</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">30</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
  <div id="toTop" class="fa fa-chevron-up"></div>
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Meng Jue (M)<br>
    </div>
  </div>
</footer>

    



<script src="/js/jquery-2.2.0.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>